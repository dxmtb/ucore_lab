# 操作系统Lab7实验报告
计24 田博 2012011346

## 练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题
### 内核级信号量的设计
semaphore_t就是内核中的信号量，主要包含up和down两个操作

具体实现中，就是使用local_intr_save来禁用中断，保证kernel不会被打断，从而实现对结构体的“原子”修改。因为不会被中断，所以不会被抢占，也就不会存在竞争。

up和down都需要处理等待的问题。down的时候如果发现信号量为0，就加入等待队列，并且调度到其它进程。up则会唤醒等待的进程，如果有的话。

### 用户态进程/线程提供信号量机制
显然用户不能采用kernel的方法，原因是用户态程序不可能关闭中断。

一种通用的方法是利用CPU提供的原子操作，这样比较高效，但是与平台相关较大。

另一种只能通过系统调用。系统提供接口创建、获取、释放信号量。系统后端的实现可以使用内核中的信号量。相应的接口就是对内核信号量进行操作，在处理wait队列的时候，队列中会是用户进程，这点会不太一样。

## 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题

### 内核级条件变量的设计描述
条件变量包含一个信号量，一个等待的计数器，以及monitor的指针。

monitor包含一个信号量数组，两个信号量，一个用于锁住monitor，另一个保证wait的进程与signal进程不冲突的衔接。

所有操作monitor的调用都要首先获取monitor的锁

cond_signal检测是否有等待条件变量的进程，如果有的话释放monitor的锁，并试图获取next锁，防止和cond_wait一起操作monitor。

cond_wait检测是否有等待被唤醒的cond_signal，如果有的话唤醒它，否则释放monitor的锁。此时试图获取条件变量的信号量，从而使得条件满足时函数返回。

### 用户态进程/线程提供条件变量机制
类似用户态信号量的实现。

## 和答案区别
思路类似

## 知识点
* 同步互斥的作用
* 同步互斥的实现
* 锁的使用方法